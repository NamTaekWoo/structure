1. Presentation 모듈

역할: 사용자 인터페이스(UI)와 사용자 상호작용을 처리하는 계층입니다. 클린 아키텍처의 프레젠테이션 레이어에 해당하며, 사용자에게 데이터를 보여주고 입력을 받아 처리하는 역할을 합니다.
주요 구성 요소:

View: UI를 구성하는 요소로, Activity, Fragment, Composable(Jetpack Compose 사용 시) 등이 포함됩니다.
ViewModel: UI와 비즈니스 로직 사이의 중재자 역할을 하며, domain 모듈에서 제공하는 유스케이스를 호출하여 데이터를 가져오거나 UI 상태를 관리합니다.
UI 관련 로직: 사용자 입력 처리, 화면 전환, 애니메이션, UI 상태 관리 등이 포함됩니다.


특징:

domain 모듈에 의존하여 비즈니스 로직을 호출하지만, data나 thirdparty 모듈에는 직접 접근하지 않습니다.
프레임워크 종속적인 코드(예: Android SDK의 Activity, Fragment)를 포함합니다.
테스트 가능성을 높이기 위해 ViewModel은 UI 로직과 비즈니스 로직을 분리합니다.


예시: 로그인 화면의 UI 구성, 사용자 입력 유효성 검사, 버튼 클릭 시 유스케이스 호출.


2. Domain 모듈

역할: 애플리케이션의 핵심 비즈니스 로직을 포함하는 계층으로, 클린 아키텍처의 도메인 레이어에 해당합니다. 이는 애플리케이션의 핵심 규칙과 로직을 정의하며, 다른 레이어와 독립적입니다.
주요 구성 요소:

UseCase (또는 Interactor): 특정 비즈니스 로직을 캡슐화한 클래스입니다. 예를 들어, LoginUseCase, FetchUserDataUseCase 등이 있습니다.
Entity: 비즈니스 데이터를 나타내는 순수 데이터 클래스입니다. 예: User, Product 등.
Repository 인터페이스: data 모듈의 데이터 소스와 상호작용하기 위한 추상화된 인터페이스입니다.


특징:

외부 프레임워크나 기술(예: Android SDK, 네트워크 라이브러리)에 의존하지 않는 순수 Kotlin/Java 코드로 작성됩니다.
가장 안정적이고 독립적인 모듈로, 다른 모듈(presentation, data)이 이 모듈에 의존합니다.
비즈니스 로직의 재사용성과 테스트 용이성을 보장합니다.


예시: 사용자 인증 로직, 데이터 유효성 검사, 비즈니스 규칙(예: "사용자가 18세 이상이어야 결제 가능").


3. Data 모듈

역할: 데이터 소스(로컬 DB, 원격 API 등)에서 데이터를 가져오고 저장하는 역할을 수행하며, 클린 아키텍처의 데이터 레이어에 해당합니다. domain 모듈의 Repository 인터페이스를 구현합니다.
주요 구성 요소:

Repository 구현체: domain 모듈의 Repository 인터페이스를 구현하여 실제 데이터 소스와 상호작용합니다.
Data Source: 데이터 소스를 추상화한 인터페이스 및 구현체로, 로컬 데이터 소스(예: Room DB)와 원격 데이터 소스(예: Retrofit API)로 나뉩니다.
Mapper: 데이터 소스의 모델(예: API 응답 DTO, Room Entity)과 domain 모듈의 Entity 간 변환 로직을 포함합니다.


특징:

thirdparty 모듈에 의존하여 외부 라이브러리(예: Retrofit, Room)를 사용합니다.
domain 모듈에 의존하여 Repository 인터페이스를 구현합니다.
데이터 소스 간 우선순위(예: 캐싱 전략, 네트워크 우선)나 에러 처리를 관리합니다.


예시: API 호출로 사용자 데이터를 가져오거나, Room DB에 데이터를 저장/조회, 네트워크 에러 처리.


4. Thirdparty 모듈

역할: 외부 라이브러리 및 프레임워크 종속적인 코드를 캡슐화하여 다른 모듈과의 결합도를 낮춥니다. 클린 아키텍처에서는 외부 시스템과의 상호작용을 추상화하는 역할을 합니다.
주요 구성 요소:

외부 라이브러리 설정: Retrofit, Room, Glide, OkHttp 등의 초기화 및 설정 코드.
서비스 인터페이스: 외부 서비스(예: 네트워크 클라이언트, 데이터베이스 클라이언트)와 상호작용하기 위한 추상화된 인터페이스 및 구현체.
어댑터: 외부 라이브러리의 데이터를 data 모듈에서 사용할 수 있도록 변환하는 어댑터 패턴.


특징:

data 모듈이 이 모듈에 의존하여 외부 데이터를 가져옵니다.
외부 라이브러리의 변경(예: Retrofit에서 Ktor로 전환) 시, 이 모듈만 수정하면 되므로 유지보수가 용이합니다.
프레임워크/라이브러리 종속적인 코드를 격리하여 클린 아키텍처의 독립성을 유지합니다.


예시: Retrofit을 사용한 API 클라이언트 설정, Room DB 초기화, 네트워크 요청을 위한 OkHttp 인터셉터 설정.


5. Design_common 모듈

역할: UI와 관련된 공통 디자인 요소 및 리소스를 관리하여 애플리케이션의 일관된 UI/UX를 보장합니다. 클린 아키텍처에서는 일반적으로 프레젠테이션 레이어의 일부로 간주되지만, 독립된 모듈로 분리하여 재사용성을 높입니다.
주요 구성 요소:

UI 컴포넌트: 재사용 가능한 UI 컴포넌트(예: 버튼, 텍스트 스타일, 다이얼로그) 또는 Jetpack Compose의 Composable 함수.
테마 및 스타일: 애플리케이션의 색상, 타이포그래피, 테마 설정(예: MaterialTheme).
리소스: 아이콘, 이미지, 문자열 등 UI 관련 공통 리소스.
유틸리티: UI 애니메이션, 레이아웃 헬퍼 등 UI 관련 공통 로직.


특징:

presentation 모듈이 이 모듈에 의존하여 일관된 UI를 구현합니다.
여러 모듈 간 UI 요소의 중복 코드를 줄이고, 디자인 시스템을 중앙화하여 유지보수를 용이하게 합니다.
디자인 변경 시 이 모듈만 수정하면 전체 앱에 반영됩니다.


예시: 앱 전반에 걸친 버튼 스타일 정의, 공통 다이얼로그 컴포넌트, 색상 팔레트 관리.


추가 참고

의존성 방향:

presentation → domain, design_common
data → domain, thirdparty
domain → (독립적, 의존성 없음)
thirdparty → (외부 라이브러리 의존, 다른 모듈에 의존하지 않음)
design_common → (독립적, 주로 presentation에서 사용)


클린 아키텍처 원칙 준수:

domain은 가장 독립적이고 핵심적인 모듈로, 비즈니스 로직을 보호합니다.
data와 thirdparty는 외부 시스템과의 상호작용을 추상화하여 유연성을 확보합니다.
presentation과 design_common은 UI와 사용자 경험을 최적화합니다.
